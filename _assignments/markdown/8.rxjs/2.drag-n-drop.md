# Drag 'n Drop
A drag and drop is a feature that can be very complex, but is made easier by using a few RxJS features.

We will make a feature where you can reorder the shelve by dragging and dropping the rows.

## Note - Advanced assignment
Implementing this feature requires more than only RxJS, because you need interaction with the DOM and HTMLElement properties.
For convenience, at the bottom of the page you can find the methods you can copy/paste and use for the non RxJS functionality.
However, if you like the challenge you can implement it yourself.

## Techniques
* Angular - Template reference variable & @ViewChildren
* RxJS - multiple operators and tie ins with Angular and DOM
* DOM - HTMLElement and style properties.

## Steps

### HTML & Styling
1. add reorder element to shelve LI
      <span class="g--1" style="cursor: pointer"> <> </span>
2. change button class g--12 to g--11 to make it look better

### get reorder elements into typescript class
1. add  #draggable to <span> in html
2. Get a reference to the `#draggable`s into the TypeScript class by using `@ViewChildren`
  ```javascript
  @ViewChildren('draggable') bookButtons: QueryList<ElementRef>
  ```
  
Properties that are decorated with @ViewChildren, are available in the afterViewInit lifecycle method.
But in our case, the buttons are only added to the view when the call to the backend has returned.
Luckily, the `bookButtons` property provides an Observable for this: `.changes`.
The `next` handler will be called any time an update to the DOM has happened that touches what you're listening for.
In our case, when an element with the `#draggable` template variable is added or removed.
  
3. print each button to the console in the right life cycle hook.
  ```javascript
  this.bookButtons.changes
  .subscribe((queryList: QueryList<ElementRef>) => {
    queryList.forEach((draggable: ElementRef) => console.log(draggable))
  });
  ```

### add drag and drop to each element
A way to think about Reactive programming is by creating a small story about what needs to happen:
when the `mousedown event` is triggered, 
  get the clientX & clientY from the `mousedown event`
  then ONLY LISTEN FOR `mousemove event`s.
  every mousemove should:
    ALSO not do the default, 
    and TRANSFORM the mouse event to an object with the new position of the element.
  UNTIL the `mouseup event` has been triggered.
    ALSO the `mouseup event` should drop the element to the new position in the DOM

In this story there are 3 events defined: `mousedown`, `mousemove` and `mouseup`. These are the Observables we need to combine.
The capitalized words in the story correspond to an Observable operator, in a sense.

#### implementation
The element we need to reorder is the `<li>`, but the element we click on is the `<span>`.
1. get a reference to the parent 'li' element using and assign it to a variable.
   `draggableSpan.nativeElement.closest('li');`

2. create 3 observables with 'fromEvent'
* 'mousedown' on draggable -> the element we want to move (li)
* 'mousemove' on document -> the position of the cursor on the document
* 'mouseup' on document -> anywhere the user let's go off the button on the document

3. We are going to start with the 'mouseDown' observable, since this is where the user starts the event.
  use `.pipe` to add the `mergeMap` operator. This corresponds to the `ONLY LISTON FOR` part of the story.
  > mergeMap operator
  > we use this operator because we want to merge the events from `mousedown` with `mousemove` events.
  > other operators we could have chosen are `concatMap` and `switchMap`.
  > see this [link](https://medium.com/@tomastrajan/practical-rxjs-in-the-wild-requests-with-concatmap-vs-mergemap-vs-forkjoin-11e5b2efe293) for an explanation.

4. in the `mergeMap` operator, pass in an 'arrow' function that returns the `mousemove` observable. This is all that is needed to connect the 2 observables.
  However, we need to use data from the `mousedown` and transform the data from `mousemove` to something we can use.
  
5. Use `({ clientX: startX, clientY: startY })` as a parameter to the arrow function in `mergeMap`. 
    This will get the properties `clientX` and `clientY` from the `mousedown`-event, and put them in the variables `startX` and `startY`.

Now, what happens by default, is that the browser wants to select text when you hold the mousedown and move it.
We want to prevent this, but we do *not* want to change the observable data. This is what we can achieve with the `tap`-operator, and `preventDefault()` from the event.
      
6. Add `pipe()` to the `mousemove` observable, and add the `tap` operator to handle the `ALSO` part in the story.
    the parameter for the arrow function is the `MouseMove` event, that has the method `preventDefault()`
    
Next, we need to transform the `MouseMove` event to a simple object that has the new position for the element we are moving.

7. add `map()` to the pipeline of `mousemove` (after `tap`). The parameter for the arrow function is the `MouseMove` event.
   use the following code to get the new location of the element we are dragging:
   ```javascript
   {
     left: e.clientX - startX,
     top: e.clientY - startY
   }
   ````

Lastly, we want to stop listening when the user lets go of the mousebutton, which is represented by the `mouseup`-observable.

8. add `takeUntil` to the pipeline, and pass in the `mouseup` observable. This will stop the observable when the observable is triggered.

All these steps will have created 1 new Observable sequence, which will drag the element with the cursor.
We still need to subscribe to this observable to execute it, and update the position of the element we are dragging.

9. Assign the sequence we just built to a new variable, `mousedrag`.
```javascript
  const mousedrag = mousedown.pipe(...);
```

10. subscribe to mousedrag, and in the `next` handler update the position of the element.
```javascript
// draggable is the element we are moving. It should be the same variable we created in step 1.
draggable.style[ 'z-index' ] = '9999';        // set the z-index very high. This paints the element above any other and will give it the floating effect.
draggable.style.position = 'relative';        // set the position property to relative, so we actually see the element move with the cursor.
draggable.style.top = position.top + 'px';    // update the top position
draggable.style.left = position.left + 'px';  // update the left position.
```

To make the element change position in the list, we need to add a pipeline to the `mouseup` observable. 
This will have a side effect that the position of the element in the DOM is updated to where the mouse is.

10. Add `pipe()` to `mouseup`, and add `tap` to handle the side effect.
  you can use the code below, or try and write your own.

# Helper methods
```javascript
  /**
  * drop the element in the dom on the current cursor position.
  **/
  private drop(x: number, y: number, draggable: any) {
      const el = this.getDrop(x, y);
      const parent = el.closest('li');
      if (parent) {
        const position = this.placeBeforeOrAfter(parent, draggable);
        parent.insertAdjacentElement(position, draggable);
      }
  
      draggable.style = 'none';  // reset position
    }
  
    /**
    * Determines if the element should be placed before or after the current element.
    * This is based off the y value. If the current element is above the dragged element, it should be placed above the current.
    * else below.
    **/
    private placeBeforeOrAfter(parent, draggable) {
      return  parent.getBoundingClientRect().top > draggable.getBoundingClientRect().top
        ? 'afterend'
        : 'beforebegin';
    }
  
    /**
    * Gets the 3rd element from any given x, y position.
    * in our application context, this will be the `li` where the user is hovering on.
    **/
    private getDrop(x: number, y: number) {
      return document.elementsFromPoint(x, y)[ 3 ];
    }
  ```
